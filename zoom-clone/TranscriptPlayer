import React, { useEffect, useRef, useState } from "react";

const rawTranscript = `
00:00:00,420 --> 00:00:34,140|Let's talk about how these things is going to happen in your W7. In the 707, we actually sort of put... think this kind of algorithm in the rule format. Okay? So instead of seeing this kind of line of code algorithm, you... what you will see is this kind of rule format. Right? It's a proof tree rule format. So in here, right, this is basically for you to compare, but essentially the meaning is the same. So in here we say, okay, the input 
00:00:34,140 --> 00:00:45,420|for this algorithm, we're starting with argument gamma, that which is a type environment, right? And then you also have given an expression 
00:00:45,420 --> 00:01:26,060|which you... x is to refer to the variable. Right? It's basically x, y, z is usually a typical, uh, variable term to represent a variable in your languages, right? And then we say, okay, that's the initial guessing, which is tau. Right? This is the three argument input. And there's a bar here, and we're using this bar to represent that, okay, yeah, you know what? This, uh, uh, is not just a proof tree, but it's also we- it's an algorithm. They will output something. So in here, what we output is a substitution map that generated by unifying, uh, the input guessing type versus the 
00:01:26,060 --> 00:01:35,520|type, uh, of the variable in the gamma type environment. Right? This is how we actually model 
00:01:35,520 --> 00:01:45,330|how we actually write down the specification for the algorithm. And then your job is to model these things into, into a OCaml code. Okay? Right? 
00:01:45,330 --> 00:01:45,360|Mm-hmm. 
00:01:45,360 --> 00:02:00,539|And then another example is the constant, right? So in the constant c cases, we say, okay, this c is a constant, and then also input argument and also initial guessing type. And then its output is a unification of the substitution map generated-`;

function parseTranscript(raw) {
  return raw
    .trim()
    .split("\n")
    .map((line) => {
      const [time, text] = line.split("|");
      const [start, end] = time.split("-->").map((t) => t.trim());
      return {
        startTime: toSeconds(start),
        endTime: toSeconds(end),
        text: text.trim(),
      };
    });
}

function toSeconds(timeStr) {
  // 00:00:00,420 ‚Üí 0.42
  const [h, m, sMs] = timeStr.split(":");
  const [s, ms] = sMs.split(",");
  return (
    Number(h) * 3600 + Number(m) * 60 + Number(s) + Number(ms) / 1000
  );
}

export default function TranscriptPlayer() {
  const transcript = parseTranscript(rawTranscript);
  const [currentLine, setCurrentLine] = useState(null);
  const [displayText, setDisplayText] = useState("");
  const [lineIndex, setLineIndex] = useState(0);
  const [playing, setPlaying] = useState(false);
  const [time, setTime] = useState(0);
  const intervalRef = useRef(null);

  // ‚è≥ Simulate video or sync with real video element if you have one
  useEffect(() => {
    if (playing) {
      intervalRef.current = setInterval(() => {
        setTime((prev) => prev + 0.5);
      }, 500);
    } else {
      clearInterval(intervalRef.current);
    }
    return () => clearInterval(intervalRef.current);
  }, [playing]);

  // üéØ Match transcript line based on time (with 1s offset)
  useEffect(() => {
    if (lineIndex < transcript.length) {
      const line = transcript[lineIndex];
      if (time >= line.startTime + 1) {
        setCurrentLine(line);
        typeOutText(line.text);
        setLineIndex((idx) => idx + 1);
      }
    }
  }, [time]);

  // ü™Ñ Typing effect
  function typeOutText(text) {
    setDisplayText("");
    let i = 0;
    const typer = setInterval(() => {
      setDisplayText((prev) => prev + text[i]);
      i++;
      if (i >= text.length) clearInterval(typer);
    }, 25); // typing speed
  }

  return (
    <div style={{ fontFamily: "Inter, sans-serif", padding: "20px" }}>
      <button onClick={() => setPlaying((p) => !p)}>
        {playing ? "Pause" : "Play"}
      </button>
      <p style={{ marginTop: "20px", whiteSpace: "pre-wrap" }}>
        {displayText || "Transcript will appear here..."}
      </p>
      <div style={{ fontSize: "12px", color: "#888" }}>‚è± {time.toFixed(1)}s</div>
    </div>
  );
}
