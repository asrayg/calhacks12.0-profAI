import React, { useEffect, useRef, useState } from "react";
import driveLogo from "./assets/drive.png";
import youtubeLogo from "./assets/youtube.png";
import canvasLogo from "./assets/canvas.png";

const rawTranscript = `
00:00:00,420 --> 00:00:34,140|LLet's talk about how these things is going to happen in your assembler. In the assembler, we actually sort of put... think this kind of algorithm in the rule format. Okay? So instead of seeing this kind of line of code algorithm, you... what you will see is this kind of rule format. Right? It's a proof tree rule format. So in here, right, this is basically for you to compare, but essentially the meaning is the same. So in here we say, okay, the input 
00:00:34,140 --> 00:00:45,420|ffor this algorithm, we're starting with argument gamma, that which is a type environment, right? And then you also have given an expression 
00:00:45,420 --> 00:01:26,060|wwhich you... x is to refer to the variable. Right? It's basically x, y, z is usually a typical, uh, variable term to represent a variable in your languages, right? And then we say, okay, that's the initial guessing, which is tau. Right? This is the three argument input. And there's a bar here, and we're using this bar to represent that, okay, yeah, you know what? This, uh, uh, is not just a proof tree, but it's also we- it's an algorithm. They will output something. So in here, what we output is a substitution map that generated by unifying, uh, the input guessing type versus the 
00:01:26,060 --> 00:01:35,520|ttype, uh, of the variable in the gamma type environment. Right? This is how we actually model 
00:01:35,520 --> 00:01:45,330|hhow we actually write down the specification for the algorithm. And then your job is to model these things into, into a OCaml code. Okay? Right? 
00:01:45,330 --> 00:01:45,360|MMm-hmm. 
00:01:45,360 --> 00:02:00,539|AAnd then another example is the constant, right? So in the constant c cases, we say, okay, this c is a constant, and then also input argument and also initial guessing type. And then its output is a unification of the substitution map generated-
`;

function toSeconds(timeStr) {
  const [h, m, sMs] = timeStr.split(":");
  const [s, ms] = sMs.split(",");
  return Number(h) * 3600 + Number(m) * 60 + Number(s) + Number(ms) / 1000;
}

function parseTranscript(raw) {
  return raw
    .trim()
    .split("\n")
    .filter((line) => line.trim().length > 0)
    .map((line) => {
      const [time, text] = line.split("|");
      if (!time || !text) return null;
      const [start, end] = time.split("-->").map((t) => t.trim());
      return {
        startTime: toSeconds(start),
        endTime: toSeconds(end),
        text: text.trim(),
      };
    })
    .filter(Boolean);
}

export default function ProfAISidePanel() {
  const transcript = parseTranscript(rawTranscript);
  const [enabled, setEnabled] = useState(false);
  const [displayText, setDisplayText] = useState("");
  const [lineIndex, setLineIndex] = useState(0);
  const [time, setTime] = useState(0);
  const [notes, setNotes] = useState([]); // üü° store notes dynamically
  const intervalRef = useRef(null);
  const typerRef = useRef(null);
  const notesBoxRef = useRef(null);

  // ‚è≥ Timer control
  useEffect(() => {
    if (enabled) {
      intervalRef.current = setInterval(() => {
        setTime((prev) => prev + 0.5);
      }, 500);
    } else {
      clearInterval(intervalRef.current);
      setTime(0);
      setLineIndex(0);
      setDisplayText("");
      setNotes([]);
    }
    return () => clearInterval(intervalRef.current);
  }, [enabled]);

  // ‚è≥ Transcript playback
  useEffect(() => {
    if (lineIndex < transcript.length && enabled) {
      const line = transcript[lineIndex];
      if (time >= line.startTime + 1) {
        typeOutText(line.text);
        appendNote(line.text); // üü° add new note as we reach it
        setLineIndex((idx) => idx + 1);
      }
    }
  }, [time, enabled]);

  // üìù Typing effect for transcript box
  function typeOutText(text) {
    if (!text || typeof text !== "string") return;
    if (typerRef.current) clearInterval(typerRef.current);

    setDisplayText("");
    const startDelay = 750;
    const typingSpeed = 45;

    setTimeout(() => {
      let i = 0;
      typerRef.current = setInterval(() => {
        if (i >= text.length) {
          clearInterval(typerRef.current);
          typerRef.current = null;
          return;
        }
        setDisplayText((prev) => prev + text[i]);
        i++;
      }, typingSpeed);
    }, startDelay);
  }

  function summarizeLine(text) {
    if (!text) return "";

    const lower = text.toLowerCase();

    if (lower.includes("assembler") || lower.includes("rule format")) {
      return "üß† Assembler Algorithm ‚Äì Rule-Based Representation\n‚Ä¢ Explains how algorithm logic is expressed using a *proof tree rule format* instead of plain code.\n‚Ä¢ This mirrors the underlying logic of the implementation.";
    }

    if (lower.includes("gamma") || lower.includes("type environment")) {
      return "üìê Type Environment (Œì)\n‚Ä¢ `Œì` holds variable-type bindings.\n‚Ä¢ Acts as the *input context* for type inference.\n‚Ä¢ Used to look up the type of identifiers during compilation.";
    }

    if (
      lower.includes("variable") ||
      lower.includes("x") ||
      lower.includes("y") ||
      lower.includes("z")
    ) {
      return "üî§ Variables in Expressions\n‚Ä¢ `x`, `y`, `z` are symbolic placeholders in language syntax.\n‚Ä¢ These are matched against Œì to infer their types.";
    }

    if (lower.includes("substitution") || lower.includes("unifying")) {
      return "üîÅ Substitution Map & Unification\n‚Ä¢ The algorithm generates a substitution by unifying the guessed type with the one found in Œì.\n‚Ä¢ This ensures type consistency across the expression.";
    }

    if (lower.includes("ocaml")) {
      return "üíª Implementation ‚Äì OCaml\n‚Ä¢ Task: translate the proof tree format into OCaml.\n‚Ä¢ Encodes algorithmic rules explicitly as functional constructs.";
    }

    if (lower.includes("constant") || lower.includes("c is a constant")) {
      return "üìå Constant Expressions\n‚Ä¢ Special case of type inference where constants have fixed types.\n‚Ä¢ Output involves unifying the guess with the constant‚Äôs type.";
    }

    // üìù fallback: short summary
    const fallback = text.length > 100 ? text.substring(0, 100) + "‚Ä¶" : text;
    return `üìù Lecture Note: ${fallback}`;
  }

  // üü° Append *summarized* live notes
  function appendNote(text) {
    const summary = summarizeLine(text);
    if (!summary) return;
    const noteObj = {
      id: Date.now(),
      text: summary,
      youtubeLink: "https://www.youtube.com/watch?v=RU1u-js7db8",
      driveLink:
        "https://drive.google.com/file/d/1oljgzVuFX8rvVuJbPSgCayE9ESEtfNgJ/view?usp=sharing",
      canvasLink: "https://canvas.iastate.edu",
    };
    setNotes((prev) => [...prev, noteObj]);
  }

  // üü° Auto-scroll notes to bottom as they come in
  useEffect(() => {
    if (notesBoxRef.current) {
      notesBoxRef.current.scrollTop = notesBoxRef.current.scrollHeight;
    }
  }, [notes]);

  return (
    <div style={styles.panel}>
      {/* HEADER */}
      <div style={styles.header}>
        <h1 style={styles.logo}>
          <span style={{ fontWeight: 700 }}>prof</span>
          <span style={{ fontWeight: 900 }}>AI</span>
        </h1>
        <div
          style={{
            ...styles.toggleOuter,
            backgroundColor: enabled ? "#4ADE80" : "#f1f1f1",
            borderColor: enabled ? "#4ADE80" : "#ccc",
          }}
          onClick={() => setEnabled(!enabled)}
        >
          <div
            style={{
              ...styles.toggleInner,
              left: enabled ? "27px" : "3px",
              backgroundColor: enabled ? "#fff" : "#999",
            }}
          />
        </div>
      </div>

      {/* TRANSCRIPT */}
      <div style={styles.card}>
        <h3 style={styles.cardHeader}>üìù Transcript</h3>
        <div style={styles.transcriptBox}>
          <p style={styles.placeholderText}>
            {enabled
              ? displayText || "Listening..."
              : "Toggle on to start live transcription."}
          </p>
        </div>
        {enabled && (
          <div style={{ fontSize: "11px", color: "#999", marginTop: "6px" }}>
            ‚è± {time.toFixed(1)}s
          </div>
        )}
      </div>

      {/* LIVE NOTES */}
      <div style={styles.card}>
        <h3 style={styles.cardHeader}>üìö Live Notes</h3>
        <div style={styles.notesBox} ref={notesBoxRef}>
          {notes.map((note) => (
            <div key={note.id} style={styles.noteItem}>
              <p style={styles.noteText}>{note.text}</p>
              <div style={styles.noteButtons}>
                <button
                  style={styles.contextButton}
                  onClick={() => window.open(note.youtubeLink, "_blank")}
                >
                  <img src={youtubeLogo} alt="YT" style={styles.icon} />
                  YouTube
                </button>
                <button
                  style={styles.contextButton}
                  onClick={() => window.open(note.driveLink, "_blank")}
                >
                  <img src={driveLogo} alt="Drive" style={styles.icon} />
                  Drive
                </button>
                <button
                  style={styles.contextButton}
                  onClick={() => window.open(note.canvasLink, "_blank")}
                >
                  <img src={canvasLogo} alt="Canvas" style={styles.icon} />
                  Canvas
                </button>
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

/* ---------- Styles ---------- */
const styles = {
  panel: {
    position: "absolute",
    background: "linear-gradient(180deg, #fff 100%, #f7f7f7 100%)",
    borderRadius: "24px",
    padding: "26px 20px",
    display: "flex",
    flexDirection: "column",
    width: "370px",
    height: "90%",
    boxShadow: "0 12px 30px rgba(0,0,0,0.15)",
    fontFamily: "Inter, sans-serif",
    color: "#111",
  },
  header: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: "22px",
  },
  logo: { fontSize: "30px", margin: 0 },
  toggleOuter: {
    width: "56px",
    height: "30px",
    borderRadius: "30px",
    border: "2px solid #ccc",
    position: "relative",
    cursor: "pointer",
    transition: "all 0.3s ease",
  },
  toggleInner: {
    width: "24px",
    height: "24px",
    borderRadius: "50%",
    position: "absolute",
    top: "2px",
    transition: "all 0.3s ease",
  },
  card: {
    backgroundColor: "#fefefe",
    borderRadius: "16px",
    padding: "18px",
    border: "1px solid rgba(0,0,0,0.05)",
    marginBottom: "22px",
    boxShadow: "0 2px 6px rgba(0,0,0,0.06)",
  },
  cardHeader: { fontSize: "15px", fontWeight: 700, marginBottom: "10px" },
  transcriptBox: {
    backgroundColor: "#fff",
    borderRadius: "12px",
    padding: "12px 14px",
    height: "140px",
    overflowY: "auto",
    border: "1px solid #e5e5e5",
  },
  placeholderText: { fontSize: "13px", color: "#666" },
  notesBox: {
    backgroundColor: "#fff",
    borderRadius: "12px",
    padding: "12px 14px",
    height: "200px",
    overflowY: "auto",
    border: "1px solid #e5e5e5",
  },
  noteItem: {
    marginBottom: "14px",
    paddingBottom: "10px",
    borderBottom: "1px solid #eee",
  },
  noteText: { fontSize: "13px", color: "#333", marginBottom: "6px" },
  noteButtons: { display: "flex", gap: "6px", flexWrap: "wrap" },
  contextButton: {
    display: "flex",
    alignItems: "center",
    backgroundColor: "#f8f9fa",
    border: "1px solid #e2e2e2",
    borderRadius: "8px",
    padding: "4px 8px",
    fontSize: "12px",
    fontWeight: 600,
    color: "#333",
    cursor: "pointer",
    gap: "4px",
  },
  icon: { width: "16px", height: "16px" },
};
